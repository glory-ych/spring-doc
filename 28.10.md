# 28.10 客户端访问RESTFul服务 #
`RestTemplate`是客户端访问`RESTFul`服务的核心类。概念上它和Spring其他的模板类相似，例如`JdbcTemplate`和`JmsTemplate`，以及其他Spring组合项目中发现的模板类。
`RestTemplate`行为可以通过提供回调方法和配置`HttpMessageConverter`来进行自定义，`HttpMessageConverter`被用于将对象整合到Http请求体以及将响应分散到对象。Spring通常使用XML作为消息格式，提供了使用`org.springframework.oxm`包中Object-to-XML框架的`MarshallingHttpMessageConverter`类。这也给了你更多有关XML到对象映射技术的选择。
本部分描述了如何使用`RestTemplate`以及它所关联的`HttpMessageConverters`。
## 28.10.1 RestTemplate ##
在Java中调用RESTful服务比较典型的做法是使用帮助类，比如Apache的Http组件`HttpClient`。这种方式对于一般的REST操作太低级，如下所示：
```
String uri = "http://example.com/hotels/1/bookings";
PostMethod post = new PostMethod(uri);
String request = // create booking request content
post.setRequestEntity(new StringRequestEntity(request));
httpClient.executeMethod(post);
if (HttpStatus.SC_CREATED == post.getStatusCode()) {
   Header location = post.getRequestHeader("Location");
   if (location != null) {
   System.out.println("Created new booking at :" + location.getValue());
   }
}
```

`RestTemplate`提供了对应于六种主要的Http方法的高级方法，从而用一行代码就能调用多个RESTFul服务，同时也强化REST最佳实践。
| HTTP Method | RestTemplate Method  
| ----- | ----- 
|DELETE | delete | |
|GET | getForObject getForEntity | |
|HEAD | headForHeaders(String url, String…​ urlVariables) | |
|OPTIONS | optionsForAllow(String url, String…​ urlVariables) | |
|POST | postForLocation(String url, Object request, String…​ urlVariables) postForObject(String url, Object request, Class<T> responseType, String…​ uriVariables) | |
|PUT | put(String url, Object request, String…​urlVariables) | |
|PATCH and others | exchange execute | |

`RestTemplate`方法命名遵循一种规则，第一部分表明哪一个Http方法被调用，第二部分表明返回值是什么。例如，`getForObject`方法会执行GET，并且将Http响应转换成你所选择的对象类型后将该对象返回。`postForLocation`方法对执行POST，将给出的对象转换成Http请求，返回能够找到新建对象的Http响应位置头信息。假如Http请求发生异常，会抛出`RestClientException`型异常。这种行为可以通过将另一个`ResponseErrorHandler`实现嵌入`RestTemplate`来改变。 

这些交换和执行方法是上面列出的更多特殊方法的广义版本，能支持额外的组合和方法，例如`Http PATCH`.然而要注意的是，底层(underlying)Http库也必须支持想要的组合.JDK中`HttpURLConnection`不支持`PATCH`方法，但是Apache的Http组件`HttpClient` 4.2及之后版本支持.他们也使`RestTemplate`可以读取Http响应为一个泛型(generic type)类(如`List<Account>`)，这里使用了一个新类`ParameterizedTypeReference`它可以捕获并且传递泛型信息.

通过`HttpMessageConverter`实例这些方法接收并返回的对象可以和Http消息进行相互转换.默认注册了主要媒体类型(mime type)的转换器，但是你也可以写自己的转换器并且通过`messageConverters()`对象属性进行注册.使用模板注册的转换器有`ByteArrayHttpMessageConverter`、`StringHttpMessageConverter`、`FormHttpMessageConverter`和`SourceHttpMessageConverter`.你可以用`messageConverters()`对象属性重写这些默认转换器，如果`MarshallingHttpMessageConverter`或`MappingJackson2HttpMessageConverter`这些对象属性也是必要的.

每个方法放置URI模板参数到两个占位，变长字符串参数或`Map<String,String>`.例如用变长字符串：
```
String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/bookings/{booking}", String.class,"42", "21");
```
用`Map<String,String>`：
```
Map<String, String> vars = Collections.singletonMap("hotel", "42");
String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);
```

可以调用默认无参构造函数来创建`RestTemplate`实例.这将会使用来自`java.net`包的标准java类作为底层实现来创建Http请求.可以通过具体指定一个`ClientHttpRequestFactory`实现进行重写.Spring提供了实现`HttpComponentsClientHttpRequestFactory`，它使用Apache的Http组件`HttpClient`创建Http请求.
使用`org.apache.http.client.HttpClient`的一个实例配置`HttpComponentsClientHttpRequestFactory`，`HttpClient`可以用证书信息和连接池函数依次配置.

*Http请求的java.net实现在接收一个代表错误(如：401)的响应码时可能会触发异常.如果发生这种情况，切换到HttpComponentsClientHttpRequestFactory进行替换.*

上述使用`HttpClient`示例直接改写为使用`RestTemplate`如下所示：
```
uri = "http://example.com/hotels/{id}/bookings";
RestTemplate template = new RestTemplate();
Booking booking = // create booking object
URI location = template.postForLocation(uri, booking, "1");
```

为了使用Apache Http组件代替`java.net`本地函数，可以用如下方式构造`RestTemplate`：
```
RestTemplate template = new RestTemplate(new HttpComponentsClientHttpRequestFactory());
```

*Apache HttpClient支持gzip编码，如果想使用就需要构建HttpComponentsClientHttpRequestFactory如下所示：*
```
HttpClient httpClient = HttpClientBuilder.create().build();
ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
RestTemplate restTemplate = new RestTemplate(requestFactory);
```

调用执行方法的时候常规回调接口`RequestCallback`也会被调用.
```
public <T> T execute(String url, HttpMethod method, RequestCallback requestCallback,
        ResponseExtractor<T> responseExtractor, String... urlVariables)
```

接口`RequestCallback`定义：
```
public interface RequestCallback {
  void doWithRequest(ClientHttpRequest request) throws IOException;
}
```
它允许你去操作请求头和写入请求体.在使用`execute`方法的时候你不必担心对所有资源的管理，模板会进行请求关闭和错误处理.有关`execute`方法的更多使用信息以及它的其他参数含义，请参考API文档.

### 使用URI ###
对于每种主要Http方法，`RestTemplate`都提供了第一参数为字符串URI或`java.net.URI`的变体.
字符串URI变体接收模板参数作为变长字符串参数或`Map<String,String>`.他们也假设URL字符串没有编码且需要编码，示例如下：
`restTemplate.getForObject("http://example.com/hotel list", String.class);`
示例会在`http://example.com/hotel%20list`上执行一次GET.这就意味着如果输入URL字符串已经编码，会发生二次编码.`http://example.com/hotel%20list`会变成`http://example.com/hotel%2520list`.如果这不符合预期效果(intended effect)，使用`java.net.URI`方法变体，这种变体会假设URL已经编码，如果你想多次重复使用一个单一URI，这非常有用.

支持URI模板的类`UriComponentsBuilder`能够用于URI的创建及编码.比如你可以用一个URL字符串作为开始:
```
UriComponents uriComponents = UriComponentsBuilder.fromUriString("http://example.com/hotels/{hotel}/bookings/{booking}").build().expand("42", "21").encode();
URI uri = uriComponents.toUri();
```
或者单独指定每一个URI组件:
```
UriComponents uriComponents = UriComponentsBuilder.newInstance().scheme("http").host("example.com").path("/hotels/{hotel}/bookings/{booking}").build().expand("42", "21").encode();
URI uri = uriComponents.toUri();
```
### 处理请求和响应头 ###
除了上面描述的方法之外，`RestTemplate`还有`exchange`方法，它基于`HttpEntity`类，可用于任意Http方法的执行.
也许总重要的是，`exchange`方法可以用来增加请求头以及读取响应头.例如：
`
HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.set("MyRequestHeader", "MyValue");
HttpEntity<?> requestEntity = new HttpEntity(requestHeaders);
HttpEntity<String> response = template.exchange("http://example.com/hotels/{hotel}",HttpMethod.GET, requestEntity, String.class, "42");
String responseHeader = response.getHeaders().getFirst("MyResponseHeader");
String body = response.getBody();
`
在上面的示例中，我们首先准备了一个包含`MyRequestHeader`头的请求实体，然后重新取得响应并读取响应头`MyRequestHeader`和响应体.

### Jackson JSON视图支持 ###
可以指定一个Jackson JSON视图来序列化一个对象属性子集，例如：
`
MappingJacksonValue value = new MappingJacksonValue(new User("eric", "7!jd#h23"));
value.setSerializationView(User.WithoutPasswordView.class);
HttpEntity<MappingJacksonValue> entity = new HttpEntity<MappingJacksonValue>(value);
String s = template.postForObject("http://example.com/user", entity, String.class);
`